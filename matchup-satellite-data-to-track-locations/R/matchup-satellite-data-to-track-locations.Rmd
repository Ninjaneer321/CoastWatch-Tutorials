---
title: Matchups satellite data to animal tracks
author: NOAA CoastWatch
date: May 20, 2021
output:
  md_document:
    variant: gfm
---

# Matchups to ship or animal tracks

history | Modified August 2023

In this exercise you will extract satellite data around a set of points defined by longitude, latitude, and time coordinates, like that produced by an animal telemetry tag, and ship track, or a glider tract.

**The exercise demonstrates the following techniques:**
* Importing track data in csv file to data frame
* Plotting the latitude/longitude points onto a map
* Extracting satellite data along a track
* Building an ERDDAP data-request URL
* Saving results as a CSV file
* Plotting the satellite data onto a map

**Datasets used:**
* Chlorophyll a concentration from the European Space Agency's Ocean Colour Climate Change Initiative Monthly dataset v6.0

* A loggerhead turtle telemetry track that has been subsample to reduce the data requests needed for this tutorial from over 1200 to 25. The turtle was raised in captivity in Japan, then tagged and released on 05/04/2005 in the Central Pacific. Its tag transmitted for over 3 years and went all the way to the Southern tip of Baja California. The track data are stored in the data folder in this project folder.


## Install required packages and load libraries
```{r install,message=FALSE,warning=FALSE}

# Function to check if pkgs are installed, and install any missing pkgs

pkgTest <- function(x)
{
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,dep=TRUE,repos='http://cran.us.r-project.org')
    if(!require(x,character.only = TRUE)) stop(x, " :Package not found")
  }
}

# create list of required packages
list.of.packages <- c("ncdf4", "rerddap", "plotdap", "parsedate", "ggplot2",'rnaturalearth', 'rnaturalearthdata',
                      "graphics", "maps", "mapdata", "RColorBrewer", "ggplot2", "gifski", 
                      "png", "rerddapXtracto")

# create list of installed packages
pkges = installed.packages()[,"Package"]

# Install and load all required pkgs
for (pk in list.of.packages) {
  pkgTest(pk)
}

```
## Import the track data into data frame

```{r tag}
# Import csv file into a data frame
turtle_df <- read.csv("../data/25317_05_subsampled.dat")

# Show 3 rows from the data frame
head(turtle_df,3)
```

## Plot the track on a map

```{r}


```


##Prepare track data for use in the ERDDAP data-request URL

* Define the search "radius" for the gridded data. The **rxtracto** function allow you to set the size of the box used to collect data around the track points using the xlen and ylen arguments. The values for xlen and ylen are in degrees. For our example we 0.2 degrees for both arguments. Note: You can also submit vectors for xlen and ylen, as long as the are the same length as xcoord, ycoord, and tcoord

* Run the rxtracto function to extract the data from ERDDAP.  
```{r}

dataset <- 'esa-cci-chla-monthly-v6-0'
rerddap::cache_delete_all(force = TRUE)
dataInfo <- rerddap::info(dataset, url= "https://oceanwatch.pifsc.noaa.gov/erddap")
# Display the metadata
dataInfo
```

```{r rxtracto, message=FALSE}
library('rerddapXtracto')
parameter <- 'chlor_a'

xlen <- 0.2 
ylen <- 0.2

xcoords <- turtle_df$mean_lon
ycoords <- turtle_df$mean_lat
tcoords <- turtle_df$date
chl_grid <- rxtracto(dataInfo, 
                  parameter=parameter, 
                  xcoord=xcoords, ycoord=ycoords, 
                  tcoord=tcoords, xlen=xlen, ylen=ylen)

```

```{r}
require("ggplot2")
require("plotdap")

myPlot <- plotTrack(chl_grid, xcoords, ycoords, tcoords, plotColor = 'algae')
myPlot
```


## Plotting the results

We will use the "plotTrack" function to plot the results.  
* "plotTrack" is a function of the "rerddapXtracto" package designed specifically to plot the results from "rxtracto".  

* The example below uses a color palette specifically designed for chlorophyll. 
  
```{r plot}
# Uncomment the png line and the dev.off() line to save the image
# png(file="xyt_matchup.png")

plotTrack(swchl, xcoord, ycoord, tcoord, plotColor = 'algae')

#dev.off()
```

## Animating the track

Make a cumulative animation of the track. This will take a minute to run. It creates an animated gif that will display in the Rstudio viewer window once the encoding to gif is done.

```{r track}
plotTrack(swchl, xcoord, ycoord, tcoord, plotColor = 'algae',
                    animate = TRUE, cumulative = TRUE)
```

## Try this on your own
This match up was done using weekly (8-day) data. Try rerunning the example using the daily (erdSW2018chla1day) or the monthly (erdSW2018chlamday) satellite data product and see how the results differ 

## Crossing the Dateline
In July 2019 version 0.4.1 of "reddapXtracto"" was updated allowing "rxtracto"" to work on data that crosses the dateline. In this example we will extract chlorophyll data for a grid of stations along the Aleutian Islands. 

__Create a station array__   
For crossing the dateline the longitudes for that animal/ship track must be in 0-360 format.  
* Create a grid of stations from 172E to 170W (190°) and 50-54N, spaced every 2°.
* Then, set up vectors with these values, and then make arrays of the station longitudes and latitudes

```{r stn}
lat <- seq(50,54,2)
lon <- seq(173,189,2)

stax <- matrix(lon,nrow=length(lat),ncol=length(lon),byrow=TRUE)
stay <- matrix(lat,nrow=length(lat),ncol=length(lon),byrow=FALSE)
```

To input values into "rxtracto" the longitudes and latitudes need to be in vector format
```{r addvals}
xcoord <- as.vector(stax) 
ycoord <- as.vector(stay) 
```

Define the search "radius" in the x any y directions, in units of degrees
```{r}
xlen <- 0.2 
ylen <- 0.2 
```

Create an array of dates. For this exercise we are going to assume all stations were sampled in the same month, so we are going to make all the values the same, but they don't have to be.   

```{r dates}
tcoord <- rep('2019-04-15',length(xcoord))
```

Selects the dataset and parameter for the extraction  
In this example the dataset chosen is the monthly OC-CCI chlorophyll data 
```{r}
url <- "https://coastwatch.pfeg.noaa.gov/erddap/"
dataset <- 'pmlEsaCCI50OceanColorMonthly'
dataInfo <- rerddap::info(dataset,url=url)
parameter <- 'chlor_a'
```

## Look at DataInfo to see if dataset has an altitude dimension. 

```{r dinfo}
dataInfo
```


This dataset does not have an altitude dimension, so we do not need to supply an altitude parameter in the following "rxtracto" call. 

Note that in both rxtracto() and rxtracto_3D() the zcoord can be a range. 
* For rxtracto_3D() if the zCoord needs to be given, it must be of length two. 
* For rxtracto() if the zCoord needs to be given, it must be of the same length as the other coordinates, and can also have a “zlen”“, like ”xlen" and “ylen”, that defines a bounding box within which to make the extract. 
* The advantage of this is it allows rxtracto() to make extracts moving in (x, y, z, t) space.

## Matchup satelite data and station locations using rxtracto()
Now we will make the rxtracto call to match up satellite data with station locations.  
```{r matchup}
chl <- rxtracto(dataInfo, 
                  parameter=parameter, 
                  xcoord=xcoord, ycoord=ycoord, 
                  tcoord=tcoord, xlen=xlen, ylen=ylen)
```


Next we will map the data. We will do this two different ways, using base graphics and using "ggplot".  

Note that "plotTrack", the routine used in the example above, is part of the "rerddapXtracto" package, and is designed to easily plot the output from "rxtracto", but currently it can not handle crossing the dateline, so we can't use it for this example. 

## Map Method 1: Make a map using base graphics  

First set up the color palette. 
This will use a yellow-green palette from the Brewer package  


```{r m1}
cols <- brewer.pal(n = 9, name = "YlGn")
chlcol <- cols[as.numeric(cut(chl$'mean chlor_a',breaks = 9))]
```

Identify stations which have a satellite values

```{r stid}
gooddata <- !is.na(chl$'mean chlor_a')
```

Set-up the layout to have a map and a color bar 

```{r layout}
oldmar <- par("mar")
layout(t(1:2),widths=c(6,1))
par(mar=c(4,4,1,.5))
```

Create the base map, and then overlay stations with data, and then overlay empty circles around all statons 
```{r basmap}
ww2 <- map('world', wrap=c(0,360), plot=FALSE, fill=TRUE)
map(ww2, xlim = c(140, 240),ylim=c(45,70), fill=TRUE,col="gray80",lforce="e")
map.axes(las=1)

points(xcoord[gooddata],ycoord[gooddata],col=chlcol, pch=19, cex=.9)
points(xcoord,ycoord, pch=1, cex=.9)
```

Add the colorbar 
```{r colorbar}
par(mar=c(4,.5,5,3))
chlv <- min(chl$'mean chlor_a'[gooddata])+(0:9)*(max(chl$'mean chlor_a'[gooddata])-min(chl$'mean chlor_a'[gooddata]))/10
image(y=chlv,z=t(1:9), col=cols, axes=FALSE, main="Chl", cex.main=.8)
axis(4,mgp=c(0,.5,0),las=1)
```


## Map Method 2: ggplot graphics  
ggplot handles colorbars much easier than base graphics! 

Put station lat, long and chl values into a dataframe for passing to ggplot 
 
```{r adddf}
chlsta <- data.frame(x=xcoord,y=ycoord,chl=chl$'mean chlor_a')
```

Get land boundary data in 0-360 units of longitude. 

```{r land}
mapWorld <- map_data("world", wrap=c(0,360))
```

Make the map 
```{r map1}
ggplot(chlsta) +
  geom_point(aes(x,y,color=chl)) +
  geom_polygon(data = mapWorld, aes(x=long, y = lat, group = group)) + 
  coord_cartesian(xlim = c(140,240),ylim = c(47,70)) +
  scale_color_gradientn(colours=brewer.pal(n = 8, name = "YlGn")) +
  labs(x="", y="")
```



      



